#!/usr/bin/env python3
"""Propagate symbols between binary versions via Binary Ninja's HTTP API.

Computes function-level hashes using the same algorithm as Ghidra's
propagate_symbols.py, enabling cross-tool hash file interoperability.

Modes:
  export  - Export hashes from the currently loaded BN binary
  import  - Import hashes and rename matching unnamed functions

Hash format (one line per function):
  sha256_hex address function_name size

The hash is computed from function size + instruction mnemonics + mnemonic
count, matching the Ghidra propagate_symbols.py format exactly.

Requires Binary Ninja running with the binary_ninja_mcp plugin active.
"""

import hashlib
import json
import struct
import sys
import urllib.request
import urllib.error

DEFAULT_BN_URL = "http://localhost:9009"
FETCH_LIMIT = 999999

# BN auto-generated name prefixes to skip when exporting
AUTO_PREFIXES = (
    "sub_",
    "data_",
    "j_",
    "byte_",
    "word_",
    "dword_",
    "qword_",
    "float_",
    "double_",
    "var_",
    "arg_",
)


def fetch_json(url: str, timeout: int = 600) -> dict:
    """Fetch JSON from a URL."""
    req = urllib.request.Request(url)
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return json.loads(resp.read())


def post_json(url: str, payload: dict, timeout: int = 600) -> dict:
    """POST JSON to a URL and return the response."""
    data = json.dumps(payload).encode("utf-8")
    req = urllib.request.Request(url, data=data, method="POST")
    req.add_header("Content-Type", "application/json")
    with urllib.request.urlopen(req, timeout=timeout) as resp:
        return json.loads(resp.read())


def is_auto_name(name: str) -> bool:
    """Return True if the name is auto-generated by Binary Ninja."""
    for prefix in AUTO_PREFIXES:
        if name.startswith(prefix):
            return True
    return False


def export_hashes(bn_url: str, output_path: str):
    """Export function hashes from BN via the propagation API."""
    print(f"Exporting function hashes from {bn_url}...")

    total_exported = 0
    offset = 0
    batch_size = 5000

    with open(output_path, "w") as f:
        f.write("# Function hashes for cross-version matching\n")
        f.write("# hash | address | name | size\n")

        while True:
            url = (
                f"{bn_url}/wowemulation/propagateSymbols"
                f"?mode=export&offset={offset}&limit={batch_size}"
            )
            data = fetch_json(url)

            if "error" in data and "entries" not in data:
                print(f"Error: {data['error']}", file=sys.stderr)
                sys.exit(1)

            entries = data.get("entries", [])
            if not entries:
                break

            for entry in entries:
                f.write(
                    "{} {} {} {}\n".format(
                        entry["hash"],
                        entry["address"],
                        entry["name"],
                        entry["size"],
                    )
                )
                total_exported += 1

            offset += len(entries)
            total = data.get("total", 0)
            print(f"  Exported {total_exported}/{total} functions...", end="\r")

            if offset >= total:
                break

    print(f"\nExported {total_exported} function hashes to {output_path}")


def import_and_match(bn_url: str, input_path: str):
    """Import hashes from a file and match against the loaded BN binary."""
    # Load source hashes
    source_hashes = {}
    with open(input_path, "r") as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith("#"):
                continue
            parts = line.split()
            if len(parts) >= 4:
                h, addr, name = parts[0], parts[1], parts[2]
                size = int(parts[3])
                source_hashes[h] = (addr, name, size)

    print(f"Loaded {len(source_hashes)} source function hashes from {input_path}")

    # Send to BN for matching
    url = f"{bn_url}/wowemulation/propagateSymbols"
    payload = {
        "mode": "import",
        "source_hashes": [
            {"hash": h, "address": addr, "name": name, "size": size}
            for h, (addr, name, size) in source_hashes.items()
        ],
    }

    print("Sending hashes to BN for matching...")
    data = post_json(url, payload)

    if "error" in data:
        print(f"Error: {data['error']}", file=sys.stderr)
        sys.exit(1)

    matched = data.get("matched", 0)
    total = data.get("total_functions", 0)
    collisions = data.get("collisions", 0)

    print(f"\nResults:")
    print(f"  Total functions in target: {total}")
    print(f"  Matched: {matched}")
    print(f"  Hash collisions (size mismatch): {collisions}")
    print(f"  Source hashes available: {len(source_hashes)}")


def usage():
    print(
        f"Usage: {sys.argv[0]} <export|import> <file-path> [--bn-url URL]",
        file=sys.stderr,
    )
    print("", file=sys.stderr)
    print("  export  Export hashes from the loaded BN binary", file=sys.stderr)
    print("  import  Import hashes and rename matching functions", file=sys.stderr)
    sys.exit(1)


def main():
    if len(sys.argv) < 3:
        usage()

    mode = sys.argv[1].lower()
    file_path = sys.argv[2]
    bn_url = DEFAULT_BN_URL

    # Parse optional --bn-url
    args = sys.argv[3:]
    i = 0
    while i < len(args):
        if args[i] == "--bn-url" and i + 1 < len(args):
            bn_url = args[i + 1].rstrip("/")
            i += 2
        else:
            print(f"Unknown argument: {args[i]}", file=sys.stderr)
            sys.exit(1)

    # Test connection
    try:
        fetch_json(f"{bn_url}/status")
    except urllib.error.URLError as e:
        print(f"Error: cannot connect to BN at {bn_url}: {e}", file=sys.stderr)
        sys.exit(1)

    if mode == "export":
        export_hashes(bn_url, file_path)
    elif mode == "import":
        import_and_match(bn_url, file_path)
    else:
        print(f"Unknown mode '{mode}'. Use 'export' or 'import'.", file=sys.stderr)
        sys.exit(1)


if __name__ == "__main__":
    main()
